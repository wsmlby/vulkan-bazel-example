#version 450

layout(constant_id = 0) const uint WORKGROUP_SIZE = 256;
layout(local_size_x_id = 0) in;

layout(push_constant) uniform PushConstants {
    uint N;         // Batch size
    uint C;         // Input channels
    uint H;         // Input height
    uint W;         // Input width
    uint K;         // Output channels
    uint R;         // Kernel height
    uint S;         // Kernel width
    uint outH;      // Output height
    uint outW;      // Output width
    uint padH;      // Padding height
    uint padW;      // Padding width
    uint strideH;   // Stride height
    uint strideW;   // Stride width
    uint dilationH; // Dilation height
    uint dilationW; // Dilation width
    uint groups;    // Number of groups
    uint hasBias;   // 1 if bias present, 0 otherwise
} params;

layout(binding = 0) readonly buffer Input { float input_data[]; };
layout(binding = 1) readonly buffer Weight { float weight_data[]; };
layout(binding = 2) writeonly buffer Output { float output_data[]; };
layout(binding = 3) readonly buffer Bias { float bias_data[]; };

void main() {
    uint idx = gl_GlobalInvocationID.x;
    uint totalOutputs = params.N * params.K * params.outH * params.outW;
    if (idx >= totalOutputs) return;

    // Decode output index: [n, k, oh, ow]
    uint ow = idx % params.outW;
    uint temp = idx / params.outW;
    uint oh = temp % params.outH;
    temp = temp / params.outH;
    uint k = temp % params.K;
    uint n = temp / params.K;

    // Compute convolution
    float sum = 0.0;

    uint channelsPerGroup = params.C / params.groups;
    uint filtersPerGroup = params.K / params.groups;
    uint group = k / filtersPerGroup;
    uint kInGroup = k % filtersPerGroup;

    for (uint c = 0; c < channelsPerGroup; c++) {
        uint actualC = group * channelsPerGroup + c;
        for (uint r = 0; r < params.R; r++) {
            for (uint s = 0; s < params.S; s++) {
                int ih = int(oh * params.strideH) - int(params.padH) + int(r * params.dilationH);
                int iw = int(ow * params.strideW) - int(params.padW) + int(s * params.dilationW);

                if (ih >= 0 && ih < int(params.H) && iw >= 0 && iw < int(params.W)) {
                    // Input index: [n, c, h, w] -> n*C*H*W + c*H*W + h*W + w
                    uint inputIdx = n * params.C * params.H * params.W +
                                    actualC * params.H * params.W +
                                    uint(ih) * params.W + uint(iw);

                    // Weight index: [k, c, r, s] -> k*Cin*R*S + c*R*S + r*S + s
                    uint weightIdx = k * channelsPerGroup * params.R * params.S +
                                     c * params.R * params.S +
                                     r * params.S + s;

                    sum += input_data[inputIdx] * weight_data[weightIdx];
                }
            }
        }
    }

    // Add bias if present
    if (params.hasBias != 0u) {
        sum += bias_data[k];
    }

    // Output index: [n, k, oh, ow]
    output_data[idx] = sum;
}
